"""
3D Mesh Serving API for MAGNET

FastAPI endpoints for serving STL mesh files generated by the physics engine.
Provides mesh retrieval, listing, and metadata endpoints for the 3D viewer frontend.

Endpoints:
1. GET /api/mesh/{design_id} → Serve STL file
2. GET /api/meshes/list → List available meshes with pagination
3. GET /api/mesh/{design_id}/metadata → Get mesh metadata

Author: Agent 3 (3D Visualization Lead)
Task: 3.3 - Mesh Serving API
Date: 2025-11-20
"""

import json
from pathlib import Path
from typing import List, Dict, Any, Optional
from datetime import datetime

from fastapi import FastAPI, HTTPException, Query
from fastapi.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel


# ============================================================
# Configuration
# ============================================================

MESH_DIR = Path("outputs/meshes/current")
ARCHIVE_DIR = Path("outputs/meshes/archive")
DEMO_DIR = Path("outputs/meshes/demo")


# ============================================================
# Pydantic Models
# ============================================================

class MeshMetadata(BaseModel):
    """Mesh metadata model."""
    vertex_count: int
    face_count: int
    volume: float
    surface_area: float
    center_of_buoyancy: List[float]
    bounds: List[List[float]]
    is_watertight: bool


class MeshInfo(BaseModel):
    """Mesh info summary for list endpoint."""
    design_id: str
    file_size: int
    created_at: float
    url: str
    metadata_url: str


class MeshListResponse(BaseModel):
    """Response model for mesh list endpoint."""
    meshes: List[MeshInfo]
    total: int
    limit: int
    offset: int


# ============================================================
# FastAPI App
# ============================================================

app = FastAPI(
    title="MAGNET 3D Mesh API",
    version="1.0.0",
    description="Serves STL mesh files for 3D visualization"
)

# Add CORS middleware for frontend access
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify exact origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ============================================================
# Helper Functions
# ============================================================

def find_mesh_file(design_id: str) -> Optional[Path]:
    """
    Find mesh file by design ID.

    Searches in order:
    1. current/ directory
    2. archive/ directory
    3. demo/ directory

    Args:
        design_id: Design identifier

    Returns:
        Path to mesh file or None if not found
    """
    # Try current directory first
    mesh_path = MESH_DIR / f"{design_id}.stl"
    if mesh_path.exists():
        return mesh_path

    # Try archive
    if ARCHIVE_DIR.exists():
        mesh_path = ARCHIVE_DIR / f"{design_id}.stl"
        if mesh_path.exists():
            return mesh_path

    # Try demo directory
    if DEMO_DIR.exists():
        # Check root
        mesh_path = DEMO_DIR / f"{design_id}.stl"
        if mesh_path.exists():
            return mesh_path

        # Check subdirectories (lod, morph)
        for subdir in DEMO_DIR.rglob("*.stl"):
            if subdir.stem == design_id:
                return subdir

    return None


def find_metadata_file(design_id: str) -> Optional[Path]:
    """
    Find metadata JSON file for a design.

    Args:
        design_id: Design identifier

    Returns:
        Path to metadata file or None
    """
    # Metadata stored alongside mesh as .json
    mesh_file = find_mesh_file(design_id)
    if mesh_file:
        metadata_path = mesh_file.parent / f"{design_id}_metadata.json"
        if metadata_path.exists():
            return metadata_path

    return None


def get_mesh_files(directory: Path, limit: int = 100, offset: int = 0) -> List[Path]:
    """
    Get list of mesh files from directory with pagination.

    Args:
        directory: Directory to search
        limit: Maximum number of results
        offset: Number of results to skip

    Returns:
        List of mesh file paths
    """
    if not directory.exists():
        return []

    # Get all STL files, sorted by modification time (newest first)
    mesh_files = sorted(
        directory.glob("*.stl"),
        key=lambda p: p.stat().st_mtime,
        reverse=True
    )

    # Apply pagination
    return mesh_files[offset:offset + limit]


# ============================================================
# API Endpoints
# ============================================================

@app.get("/")
async def root():
    """API root - health check."""
    return {
        "status": "online",
        "api": "MAGNET 3D Mesh API",
        "version": "1.0.0",
        "endpoints": [
            "/api/mesh/{design_id}",
            "/api/meshes/list",
            "/api/mesh/{design_id}/metadata"
        ]
    }


@app.get("/api/mesh/{design_id}")
async def get_mesh(design_id: str):
    """
    Serve 3D mesh file by design ID.

    Returns binary STL file for download/viewing.

    Args:
        design_id: Unique design identifier

    Returns:
        FileResponse with STL file

    Raises:
        HTTPException: 404 if mesh not found
    """
    mesh_path = find_mesh_file(design_id)

    if not mesh_path:
        raise HTTPException(
            status_code=404,
            detail=f"Mesh '{design_id}' not found"
        )

    return FileResponse(
        path=mesh_path,
        media_type="application/sla",  # STL MIME type
        filename=f"{design_id}.stl"
    )


@app.get("/api/meshes/list", response_model=MeshListResponse)
async def list_meshes(
    limit: int = Query(100, ge=1, le=1000, description="Max results to return"),
    offset: int = Query(0, ge=0, description="Number of results to skip"),
    include_demo: bool = Query(False, description="Include demo meshes")
):
    """
    List available meshes with pagination.

    Returns list of mesh files with metadata and download URLs.

    Args:
        limit: Maximum number of results (1-1000)
        offset: Number of results to skip (for pagination)
        include_demo: If True, include demo meshes

    Returns:
        MeshListResponse with mesh information
    """
    # Get meshes from current directory
    mesh_files = get_mesh_files(MESH_DIR, limit=limit * 2, offset=0)

    # Optionally include demo meshes
    if include_demo and DEMO_DIR.exists():
        demo_files = get_mesh_files(DEMO_DIR, limit=limit, offset=0)
        mesh_files.extend(demo_files)

    # Sort by modification time (newest first)
    mesh_files = sorted(
        mesh_files,
        key=lambda p: p.stat().st_mtime,
        reverse=True
    )

    # Get total count before pagination
    total = len(mesh_files)

    # Apply pagination
    mesh_files = mesh_files[offset:offset + limit]

    # Build response
    meshes = []
    for mesh_file in mesh_files:
        design_id = mesh_file.stem
        stat = mesh_file.stat()

        meshes.append(MeshInfo(
            design_id=design_id,
            file_size=stat.st_size,
            created_at=stat.st_mtime,
            url=f"/api/mesh/{design_id}",
            metadata_url=f"/api/mesh/{design_id}/metadata"
        ))

    return MeshListResponse(
        meshes=meshes,
        total=total,
        limit=limit,
        offset=offset
    )


@app.get("/api/mesh/{design_id}/metadata")
async def get_mesh_metadata(design_id: str):
    """
    Get mesh metadata (vertices, faces, volume, etc.).

    Args:
        design_id: Unique design identifier

    Returns:
        Dictionary with mesh metadata

    Raises:
        HTTPException: 404 if mesh not found
    """
    # First check if mesh exists
    mesh_path = find_mesh_file(design_id)
    if not mesh_path:
        raise HTTPException(
            status_code=404,
            detail=f"Mesh '{design_id}' not found"
        )

    # Try to load metadata JSON file
    metadata_path = find_metadata_file(design_id)

    if metadata_path:
        # Load from JSON
        with open(metadata_path, 'r') as f:
            metadata = json.load(f)
        return metadata

    else:
        # Generate metadata on-the-fly by loading mesh
        try:
            import trimesh

            mesh = trimesh.load(str(mesh_path))

            metadata = {
                "design_id": design_id,
                "vertex_count": len(mesh.vertices),
                "face_count": len(mesh.faces),
                "volume": float(mesh.volume) if hasattr(mesh, 'volume') else 0.0,
                "surface_area": float(mesh.area) if hasattr(mesh, 'area') else 0.0,
                "bounds": mesh.bounds.tolist(),
                "is_watertight": bool(mesh.is_watertight) if hasattr(mesh, 'is_watertight') else False,
                "file_size": mesh_path.stat().st_size,
                "created_at": mesh_path.stat().st_mtime
            }

            return metadata

        except Exception as e:
            raise HTTPException(
                status_code=500,
                detail=f"Failed to load mesh metadata: {str(e)}"
            )


@app.get("/api/meshes/recent")
async def get_recent_meshes(limit: int = Query(10, ge=1, le=100)):
    """
    Get most recent meshes.

    Convenience endpoint for getting latest designs.

    Args:
        limit: Maximum number of results

    Returns:
        List of recent mesh info
    """
    result = await list_meshes(limit=limit, offset=0, include_demo=False)
    return {"meshes": result.meshes, "total": result.total}


@app.get("/api/meshes/stats")
async def get_mesh_stats():
    """
    Get overall mesh statistics.

    Returns:
        Statistics about available meshes
    """
    # Count meshes in each directory
    current_count = len(list(MESH_DIR.glob("*.stl"))) if MESH_DIR.exists() else 0
    archive_count = len(list(ARCHIVE_DIR.rglob("*.stl"))) if ARCHIVE_DIR.exists() else 0
    demo_count = len(list(DEMO_DIR.rglob("*.stl"))) if DEMO_DIR.exists() else 0

    # Calculate total size
    total_size = 0
    if MESH_DIR.exists():
        total_size += sum(f.stat().st_size for f in MESH_DIR.glob("*.stl"))
    if ARCHIVE_DIR.exists():
        total_size += sum(f.stat().st_size for f in ARCHIVE_DIR.rglob("*.stl"))

    return {
        "total_meshes": current_count + archive_count + demo_count,
        "current_meshes": current_count,
        "archived_meshes": archive_count,
        "demo_meshes": demo_count,
        "total_size_mb": total_size / (1024 * 1024),
        "mesh_directory": str(MESH_DIR),
    }


# ============================================================
# Main (for standalone testing)
# ============================================================

if __name__ == "__main__":
    import uvicorn

    print("=" * 70)
    print("MAGNET 3D Mesh API Server")
    print("=" * 70)
    print()
    print("Starting server on http://localhost:8000")
    print()
    print("Available endpoints:")
    print("  GET  /api/mesh/{design_id}")
    print("  GET  /api/meshes/list")
    print("  GET  /api/mesh/{design_id}/metadata")
    print("  GET  /api/meshes/recent")
    print("  GET  /api/meshes/stats")
    print()
    print("Documentation: http://localhost:8000/docs")
    print("=" * 70)
    print()

    uvicorn.run(app, host="0.0.0.0", port=8000)
