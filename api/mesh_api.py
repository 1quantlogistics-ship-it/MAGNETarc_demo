"""
3D Mesh Serving API for MAGNET

FastAPI endpoints for serving STL mesh files generated by the physics engine.
Provides mesh retrieval, listing, and metadata endpoints for the 3D viewer frontend.

Endpoints:
1. GET /api/mesh/{design_id} → Serve STL file
2. GET /api/meshes/list → List available meshes with pagination
3. GET /api/mesh/{design_id}/metadata → Get mesh metadata
4. GET /api/meshes/compare → Compare two designs side-by-side
5. WebSocket /ws/meshes → Real-time mesh updates (Task 3.5)

Author: Agent 3 (3D Visualization Lead)
Task: 3.3 - Mesh Serving API
Task: 3.5 - WebSocket Real-Time Updates
Date: 2025-11-20
"""

import json
import asyncio
from pathlib import Path
from typing import List, Dict, Any, Optional, Set
from datetime import datetime

from fastapi import FastAPI, HTTPException, Query, WebSocket, WebSocketDisconnect
from fastapi.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel


# ============================================================
# Configuration
# ============================================================

MESH_DIR = Path("outputs/meshes/current")
ARCHIVE_DIR = Path("outputs/meshes/archive")
DEMO_DIR = Path("outputs/meshes/demo")


# ============================================================
# Pydantic Models
# ============================================================

class MeshMetadata(BaseModel):
    """Mesh metadata model."""
    vertex_count: int
    face_count: int
    volume: float
    surface_area: float
    center_of_buoyancy: List[float]
    bounds: List[List[float]]
    is_watertight: bool


class MeshInfo(BaseModel):
    """Mesh info summary for list endpoint."""
    design_id: str
    file_size: int
    created_at: float
    url: str
    metadata_url: str


class MeshListResponse(BaseModel):
    """Response model for mesh list endpoint."""
    meshes: List[MeshInfo]
    total: int
    limit: int
    offset: int


# ============================================================
# FastAPI App
# ============================================================

app = FastAPI(
    title="MAGNET 3D Mesh API",
    version="1.0.0",
    description="Serves STL mesh files for 3D visualization"
)

# Add CORS middleware for frontend access
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify exact origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ============================================================
# Helper Functions
# ============================================================

def find_mesh_file(design_id: str) -> Optional[Path]:
    """
    Find mesh file by design ID.

    Searches in order:
    1. current/ directory
    2. archive/ directory
    3. demo/ directory

    Args:
        design_id: Design identifier

    Returns:
        Path to mesh file or None if not found
    """
    # Try current directory first
    mesh_path = MESH_DIR / f"{design_id}.stl"
    if mesh_path.exists():
        return mesh_path

    # Try archive
    if ARCHIVE_DIR.exists():
        mesh_path = ARCHIVE_DIR / f"{design_id}.stl"
        if mesh_path.exists():
            return mesh_path

    # Try demo directory
    if DEMO_DIR.exists():
        # Check root
        mesh_path = DEMO_DIR / f"{design_id}.stl"
        if mesh_path.exists():
            return mesh_path

        # Check subdirectories (lod, morph)
        for subdir in DEMO_DIR.rglob("*.stl"):
            if subdir.stem == design_id:
                return subdir

    return None


def find_metadata_file(design_id: str) -> Optional[Path]:
    """
    Find metadata JSON file for a design.

    Args:
        design_id: Design identifier

    Returns:
        Path to metadata file or None
    """
    # Metadata stored alongside mesh as .json
    mesh_file = find_mesh_file(design_id)
    if mesh_file:
        metadata_path = mesh_file.parent / f"{design_id}_metadata.json"
        if metadata_path.exists():
            return metadata_path

    return None


def get_mesh_files(directory: Path, limit: int = 100, offset: int = 0) -> List[Path]:
    """
    Get list of mesh files from directory with pagination.

    Args:
        directory: Directory to search
        limit: Maximum number of results
        offset: Number of results to skip

    Returns:
        List of mesh file paths
    """
    if not directory.exists():
        return []

    # Get all STL files, sorted by modification time (newest first)
    mesh_files = sorted(
        directory.glob("*.stl"),
        key=lambda p: p.stat().st_mtime,
        reverse=True
    )

    # Apply pagination
    return mesh_files[offset:offset + limit]


# ============================================================
# WebSocket Connection Manager (Task 3.5)
# ============================================================

class ConnectionManager:
    """Manages WebSocket connections for real-time mesh updates."""

    def __init__(self):
        self.active_connections: Set[WebSocket] = set()
        self._known_meshes: Set[str] = set()
        self._monitoring = False
        self._monitor_task = None

    async def connect(self, websocket: WebSocket):
        """Accept and store a new WebSocket connection."""
        await websocket.accept()
        self.active_connections.add(websocket)

        # Start monitoring if this is the first connection
        if len(self.active_connections) == 1 and not self._monitoring:
            self._monitor_task = asyncio.create_task(self._monitor_mesh_directory())

    def disconnect(self, websocket: WebSocket):
        """Remove a WebSocket connection."""
        self.active_connections.discard(websocket)

        # Stop monitoring if no more connections
        if len(self.active_connections) == 0 and self._monitoring:
            self._monitoring = False
            if self._monitor_task:
                self._monitor_task.cancel()

    async def broadcast(self, message: Dict[str, Any]):
        """Broadcast message to all connected clients."""
        disconnected = set()

        for connection in self.active_connections:
            try:
                await connection.send_json(message)
            except Exception:
                disconnected.add(connection)

        # Clean up disconnected clients
        for connection in disconnected:
            self.disconnect(connection)

    async def _monitor_mesh_directory(self):
        """Monitor mesh directory for new files and broadcast updates."""
        self._monitoring = True

        # Initialize known meshes
        if MESH_DIR.exists():
            self._known_meshes = {f.stem for f in MESH_DIR.glob("*.stl")}

        print(f"[WebSocket] Monitoring {MESH_DIR} for new meshes...")

        try:
            while self._monitoring:
                await asyncio.sleep(1)  # Check every second

                if not MESH_DIR.exists():
                    continue

                # Get current meshes
                current_meshes = {f.stem for f in MESH_DIR.glob("*.stl")}

                # Check for new meshes
                new_meshes = current_meshes - self._known_meshes

                if new_meshes:
                    for design_id in new_meshes:
                        mesh_path = MESH_DIR / f"{design_id}.stl"
                        stat = mesh_path.stat()

                        # Broadcast new mesh event
                        await self.broadcast({
                            "event": "new_mesh",
                            "design_id": design_id,
                            "file_size": stat.st_size,
                            "created_at": stat.st_mtime,
                            "url": f"/api/mesh/{design_id}",
                            "metadata_url": f"/api/mesh/{design_id}/metadata"
                        })

                        print(f"[WebSocket] Broadcasted new mesh: {design_id}")

                    # Update known meshes
                    self._known_meshes = current_meshes

        except asyncio.CancelledError:
            print("[WebSocket] Monitoring stopped")
        except Exception as e:
            print(f"[WebSocket] Error in monitoring: {e}")
        finally:
            self._monitoring = False


# Global connection manager
manager = ConnectionManager()


# ============================================================
# API Endpoints
# ============================================================

@app.get("/")
async def root():
    """API root - health check."""
    return {
        "status": "online",
        "api": "MAGNET 3D Mesh API",
        "version": "1.0.0",
        "endpoints": [
            "/api/mesh/{design_id}",
            "/api/meshes/list",
            "/api/mesh/{design_id}/metadata"
        ]
    }


@app.get("/api/mesh/{design_id}")
async def get_mesh(design_id: str):
    """
    Serve 3D mesh file by design ID.

    Returns binary STL file for download/viewing.

    Args:
        design_id: Unique design identifier

    Returns:
        FileResponse with STL file

    Raises:
        HTTPException: 404 if mesh not found
    """
    mesh_path = find_mesh_file(design_id)

    if not mesh_path:
        raise HTTPException(
            status_code=404,
            detail=f"Mesh '{design_id}' not found"
        )

    return FileResponse(
        path=mesh_path,
        media_type="application/sla",  # STL MIME type
        filename=f"{design_id}.stl"
    )


@app.get("/api/meshes/list", response_model=MeshListResponse)
async def list_meshes(
    limit: int = Query(100, ge=1, le=1000, description="Max results to return"),
    offset: int = Query(0, ge=0, description="Number of results to skip"),
    include_demo: bool = Query(False, description="Include demo meshes")
):
    """
    List available meshes with pagination.

    Returns list of mesh files with metadata and download URLs.

    Args:
        limit: Maximum number of results (1-1000)
        offset: Number of results to skip (for pagination)
        include_demo: If True, include demo meshes

    Returns:
        MeshListResponse with mesh information
    """
    # Get meshes from current directory
    mesh_files = get_mesh_files(MESH_DIR, limit=limit * 2, offset=0)

    # Optionally include demo meshes
    if include_demo and DEMO_DIR.exists():
        demo_files = get_mesh_files(DEMO_DIR, limit=limit, offset=0)
        mesh_files.extend(demo_files)

    # Sort by modification time (newest first)
    mesh_files = sorted(
        mesh_files,
        key=lambda p: p.stat().st_mtime,
        reverse=True
    )

    # Get total count before pagination
    total = len(mesh_files)

    # Apply pagination
    mesh_files = mesh_files[offset:offset + limit]

    # Build response
    meshes = []
    for mesh_file in mesh_files:
        design_id = mesh_file.stem
        stat = mesh_file.stat()

        meshes.append(MeshInfo(
            design_id=design_id,
            file_size=stat.st_size,
            created_at=stat.st_mtime,
            url=f"/api/mesh/{design_id}",
            metadata_url=f"/api/mesh/{design_id}/metadata"
        ))

    return MeshListResponse(
        meshes=meshes,
        total=total,
        limit=limit,
        offset=offset
    )


@app.get("/api/mesh/{design_id}/metadata")
async def get_mesh_metadata(design_id: str):
    """
    Get mesh metadata (vertices, faces, volume, etc.).

    Args:
        design_id: Unique design identifier

    Returns:
        Dictionary with mesh metadata

    Raises:
        HTTPException: 404 if mesh not found
    """
    # First check if mesh exists
    mesh_path = find_mesh_file(design_id)
    if not mesh_path:
        raise HTTPException(
            status_code=404,
            detail=f"Mesh '{design_id}' not found"
        )

    # Try to load metadata JSON file
    metadata_path = find_metadata_file(design_id)

    if metadata_path:
        # Load from JSON
        with open(metadata_path, 'r') as f:
            metadata = json.load(f)
        return metadata

    else:
        # Generate metadata on-the-fly by loading mesh
        try:
            import trimesh

            mesh = trimesh.load(str(mesh_path))

            metadata = {
                "design_id": design_id,
                "vertex_count": len(mesh.vertices),
                "face_count": len(mesh.faces),
                "volume": float(mesh.volume) if hasattr(mesh, 'volume') else 0.0,
                "surface_area": float(mesh.area) if hasattr(mesh, 'area') else 0.0,
                "bounds": mesh.bounds.tolist(),
                "is_watertight": bool(mesh.is_watertight) if hasattr(mesh, 'is_watertight') else False,
                "file_size": mesh_path.stat().st_size,
                "created_at": mesh_path.stat().st_mtime
            }

            return metadata

        except Exception as e:
            raise HTTPException(
                status_code=500,
                detail=f"Failed to load mesh metadata: {str(e)}"
            )


@app.get("/api/meshes/compare")
async def compare_designs(design_id_1: str = Query(..., description="First design ID"),
                         design_id_2: str = Query(..., description="Second design ID")):
    """
    Compare two designs side-by-side.

    Returns metadata for both designs for comparison.

    Args:
        design_id_1: First design to compare
        design_id_2: Second design to compare

    Returns:
        Dictionary with metadata for both designs

    Raises:
        HTTPException: 404 if either design not found
    """
    # Get metadata for both designs
    try:
        # Fetch first design metadata
        metadata_1 = await get_mesh_metadata(design_id_1)
    except HTTPException as e:
        raise HTTPException(
            status_code=404,
            detail=f"First design '{design_id_1}' not found: {e.detail}"
        )

    try:
        # Fetch second design metadata
        metadata_2 = await get_mesh_metadata(design_id_2)
    except HTTPException as e:
        raise HTTPException(
            status_code=404,
            detail=f"Second design '{design_id_2}' not found: {e.detail}"
        )

    # Return comparison data
    return {
        "design_1": {
            "design_id": design_id_1,
            "metadata": metadata_1,
            "url": f"/api/mesh/{design_id_1}"
        },
        "design_2": {
            "design_id": design_id_2,
            "metadata": metadata_2,
            "url": f"/api/mesh/{design_id_2}"
        },
        "comparison": {
            "vertex_count_diff": metadata_2.get("vertex_count", 0) - metadata_1.get("vertex_count", 0),
            "face_count_diff": metadata_2.get("face_count", 0) - metadata_1.get("face_count", 0),
            "volume_diff": metadata_2.get("volume", 0.0) - metadata_1.get("volume", 0.0),
            "surface_area_diff": metadata_2.get("surface_area", 0.0) - metadata_1.get("surface_area", 0.0)
        }
    }


@app.get("/api/meshes/recent")
async def get_recent_meshes(limit: int = Query(10, ge=1, le=100)):
    """
    Get most recent meshes.

    Convenience endpoint for getting latest designs.

    Args:
        limit: Maximum number of results

    Returns:
        List of recent mesh info
    """
    result = await list_meshes(limit=limit, offset=0, include_demo=False)
    return {"meshes": result.meshes, "total": result.total}


@app.get("/api/meshes/stats")
async def get_mesh_stats():
    """
    Get overall mesh statistics.

    Returns:
        Statistics about available meshes
    """
    # Count meshes in each directory
    current_count = len(list(MESH_DIR.glob("*.stl"))) if MESH_DIR.exists() else 0
    archive_count = len(list(ARCHIVE_DIR.rglob("*.stl"))) if ARCHIVE_DIR.exists() else 0
    demo_count = len(list(DEMO_DIR.rglob("*.stl"))) if DEMO_DIR.exists() else 0

    # Calculate total size
    total_size = 0
    if MESH_DIR.exists():
        total_size += sum(f.stat().st_size for f in MESH_DIR.glob("*.stl"))
    if ARCHIVE_DIR.exists():
        total_size += sum(f.stat().st_size for f in ARCHIVE_DIR.rglob("*.stl"))

    return {
        "total_meshes": current_count + archive_count + demo_count,
        "current_meshes": current_count,
        "archived_meshes": archive_count,
        "demo_meshes": demo_count,
        "total_size_mb": total_size / (1024 * 1024),
        "mesh_directory": str(MESH_DIR),
    }


# ============================================================
# WebSocket Endpoint (Task 3.5)
# ============================================================

@app.websocket("/ws/meshes")
async def websocket_endpoint(websocket: WebSocket):
    """
    WebSocket endpoint for real-time mesh updates.

    Clients connect to this endpoint to receive notifications when new
    meshes are generated and added to the mesh directory.

    Events sent to clients:
    - new_mesh: When a new mesh file is detected
    - connection_ack: When client successfully connects

    Example client code:
    ```javascript
    const ws = new WebSocket('ws://localhost:8000/ws/meshes');
    ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.event === 'new_mesh') {
            console.log('New mesh:', data.design_id);
            // Refresh mesh list or load new mesh
        }
    };
    ```
    """
    await manager.connect(websocket)

    try:
        # Send connection acknowledgement
        await websocket.send_json({
            "event": "connection_ack",
            "message": "Connected to mesh update stream",
            "active_connections": len(manager.active_connections)
        })

        # Keep connection alive and wait for disconnect
        while True:
            # Receive messages from client (for heartbeat/ping)
            data = await websocket.receive_text()

            # Echo back for heartbeat
            if data == "ping":
                await websocket.send_json({"event": "pong"})

    except WebSocketDisconnect:
        manager.disconnect(websocket)
        print(f"[WebSocket] Client disconnected. Active connections: {len(manager.active_connections)}")
    except Exception as e:
        print(f"[WebSocket] Error: {e}")
        manager.disconnect(websocket)


# ============================================================
# Main (for standalone testing)
# ============================================================

if __name__ == "__main__":
    import uvicorn

    print("=" * 70)
    print("MAGNET 3D Mesh API Server")
    print("=" * 70)
    print()
    print("Starting server on http://localhost:8000")
    print()
    print("Available endpoints:")
    print("  GET        /api/mesh/{design_id}")
    print("  GET        /api/meshes/list")
    print("  GET        /api/mesh/{design_id}/metadata")
    print("  GET        /api/meshes/recent")
    print("  GET        /api/meshes/stats")
    print("  WebSocket  /ws/meshes  (real-time updates)")
    print()
    print("Documentation: http://localhost:8000/docs")
    print("=" * 70)
    print()

    uvicorn.run(app, host="0.0.0.0", port=8000)
